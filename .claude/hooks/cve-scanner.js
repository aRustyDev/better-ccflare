#!/usr/bin/env node
/**
 * CVE Scanner (grype)
 *
 * TRIGGER: PostToolUse
 * MATCHER: Write|Edit (on package.json, package-lock.json, bun.lock,
 *          requirements.txt, Pipfile.lock, go.mod, Cargo.lock, etc.)
 *
 * Scans dependency files for known CVEs using Anchore Grype.
 * Blocks on critical/high severity vulnerabilities.
 *
 * REQUIRES: grype (brew install grype / curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh)
 *
 * EXIT CODES:
 *   0 - No critical/high CVEs
 *   2 - Critical/High CVEs found (blocks)
 */

const { execSync } = require("child_process");
const path = require("path");

const projectRoot = process.env.CLAUDE_PROJECT_DIR || process.cwd();

// Dependency files that should trigger scanning
const DEPENDENCY_FILES = [
	// JavaScript/Node
	"package.json",
	"package-lock.json",
	"yarn.lock",
	"pnpm-lock.yaml",
	"bun.lock",
	"bun.lockb",
	// Python
	"requirements.txt",
	"Pipfile.lock",
	"poetry.lock",
	"setup.py",
	"pyproject.toml",
	// Go
	"go.mod",
	"go.sum",
	// Rust
	"Cargo.lock",
	"Cargo.toml",
	// Ruby
	"Gemfile.lock",
	// Java/Kotlin
	"pom.xml",
	"build.gradle",
	"build.gradle.kts",
	// .NET
	"packages.lock.json",
	"*.csproj",
	// PHP
	"composer.lock",
];

// Severity levels that should block
const BLOCKING_SEVERITIES = ["Critical", "High"];

// Severity levels to warn about
const WARNING_SEVERITIES = ["Medium"];

const colors = {
	red: "\x1b[0;31m",
	green: "\x1b[0;32m",
	yellow: "\x1b[0;33m",
	blue: "\x1b[0;34m",
	cyan: "\x1b[0;36m",
	magenta: "\x1b[0;35m",
	reset: "\x1b[0m",
};

async function parseInput() {
	let data = "";
	for await (const chunk of process.stdin) {
		data += chunk;
	}
	return data.trim() ? JSON.parse(data) : null;
}

function isDependencyFile(filePath) {
	const basename = path.basename(filePath);
	return DEPENDENCY_FILES.some(pattern => {
		if (pattern.includes("*")) {
			const regex = new RegExp(`^${pattern.replace("*", ".*")}$`);
			return regex.test(basename);
		}
		return basename === pattern;
	});
}

function checkGrypeInstalled() {
	try {
		execSync("grype version", { stdio: ["pipe", "pipe", "pipe"] });
		return true;
	} catch {
		return false;
	}
}

function runGrype(targetDir) {
	try {
		// Scan the directory containing the dependency file
		const cmd = `grype dir:${targetDir} --output json --quiet`;
		const output = execSync(cmd, {
			cwd: projectRoot,
			encoding: "utf8",
			stdio: ["pipe", "pipe", "pipe"],
			timeout: 120000, // 2 minute timeout
			maxBuffer: 50 * 1024 * 1024, // 50MB buffer
		});

		return { success: true, results: JSON.parse(output) };
	} catch (err) {
		// grype returns non-zero if vulnerabilities found
		if (err.stdout) {
			try {
				return { success: true, results: JSON.parse(err.stdout) };
			} catch {
				// Parse error
			}
		}
		if (err.stderr && !err.stderr.includes("no packages discovered")) {
			return { success: false, error: err.stderr };
		}
		return { success: true, results: { matches: [] } };
	}
}

function categorizeVulnerabilities(results) {
	const vulnerabilities = results.matches || [];
	const categorized = {
		Critical: [],
		High: [],
		Medium: [],
		Low: [],
		Negligible: [],
		Unknown: [],
	};

	for (const match of vulnerabilities) {
		const severity = match.vulnerability?.severity || "Unknown";
		const normalizedSeverity = severity.charAt(0).toUpperCase() + severity.slice(1).toLowerCase();

		if (categorized[normalizedSeverity]) {
			categorized[normalizedSeverity].push({
				id: match.vulnerability?.id || "unknown",
				package: match.artifact?.name || "unknown",
				version: match.artifact?.version || "unknown",
				fixedIn: match.vulnerability?.fix?.versions?.join(", ") || "no fix available",
				description: match.vulnerability?.description?.substring(0, 100) || "",
			});
		} else {
			categorized.Unknown.push({
				id: match.vulnerability?.id || "unknown",
				package: match.artifact?.name || "unknown",
				version: match.artifact?.version || "unknown",
				fixedIn: "unknown",
				description: "",
			});
		}
	}

	return categorized;
}

async function main() {
	const input = await parseInput();

	if (!input) {
		process.exit(0);
	}

	const { tool_input } = input;
	const filePath = tool_input?.file_path || tool_input?.path;

	if (!filePath || !isDependencyFile(filePath)) {
		process.exit(0);
	}

	const relativePath = path.relative(projectRoot, filePath);
	const targetDir = path.dirname(filePath);

	console.error("");
	console.error(`${colors.cyan}ðŸ” CVE Scanner (grype)${colors.reset}`);
	console.error("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
	console.error(`${colors.blue}[INFO]${colors.reset} Dependency file modified: ${relativePath}`);
	console.error(`${colors.blue}[INFO]${colors.reset} Scanning directory for vulnerabilities...`);

	// Check if grype is installed
	if (!checkGrypeInstalled()) {
		console.error("");
		console.error(`${colors.yellow}âš ï¸ grype not installed${colors.reset}`);
		console.error("");
		console.error(`${colors.cyan}Install with:${colors.reset}`);
		console.error("   brew install grype                    # macOS");
		console.error("   curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin");
		console.error("");
		process.exit(0);
	}

	const { success, results, error } = runGrype(targetDir);

	if (!success) {
		console.error(`${colors.red}[ERROR]${colors.reset} grype scan failed: ${error}`);
		process.exit(0);
	}

	const categorized = categorizeVulnerabilities(results);

	const criticalCount = categorized.Critical.length;
	const highCount = categorized.High.length;
	const mediumCount = categorized.Medium.length;
	const lowCount = categorized.Low.length + categorized.Negligible.length + categorized.Unknown.length;

	const totalCount = criticalCount + highCount + mediumCount + lowCount;

	if (totalCount === 0) {
		console.error(`${colors.green}âœ… No vulnerabilities found${colors.reset}`);
		process.exit(0);
	}

	// Summary
	console.error("");
	console.error(`${colors.cyan}Vulnerability Summary:${colors.reset}`);
	if (criticalCount > 0) {
		console.error(`   ${colors.red}Critical: ${criticalCount}${colors.reset}`);
	}
	if (highCount > 0) {
		console.error(`   ${colors.red}High: ${highCount}${colors.reset}`);
	}
	if (mediumCount > 0) {
		console.error(`   ${colors.yellow}Medium: ${mediumCount}${colors.reset}`);
	}
	if (lowCount > 0) {
		console.error(`   Low/Other: ${lowCount}`);
	}

	// Show critical vulnerabilities
	if (criticalCount > 0) {
		console.error("");
		console.error(`${colors.red}Critical Vulnerabilities:${colors.reset}`);
		for (const vuln of categorized.Critical.slice(0, 5)) {
			console.error(`   ${colors.red}â€¢${colors.reset} ${vuln.id}: ${vuln.package}@${vuln.version}`);
			if (vuln.fixedIn && vuln.fixedIn !== "no fix available") {
				console.error(`     ${colors.cyan}Fix:${colors.reset} Upgrade to ${vuln.fixedIn}`);
			}
		}
		if (criticalCount > 5) {
			console.error(`   ... and ${criticalCount - 5} more critical vulnerabilities`);
		}
	}

	// Show high vulnerabilities
	if (highCount > 0) {
		console.error("");
		console.error(`${colors.red}High Vulnerabilities:${colors.reset}`);
		for (const vuln of categorized.High.slice(0, 5)) {
			console.error(`   ${colors.red}â€¢${colors.reset} ${vuln.id}: ${vuln.package}@${vuln.version}`);
			if (vuln.fixedIn && vuln.fixedIn !== "no fix available") {
				console.error(`     ${colors.cyan}Fix:${colors.reset} Upgrade to ${vuln.fixedIn}`);
			}
		}
		if (highCount > 5) {
			console.error(`   ... and ${highCount - 5} more high vulnerabilities`);
		}
	}

	console.error("");
	console.error(`${colors.cyan}To see full report:${colors.reset}`);
	console.error(`   grype dir:${targetDir}`);
	console.error("");

	// Check if we should block
	const blockingCount = criticalCount + highCount;

	if (blockingCount > 0) {
		console.error(`${colors.red}â›” Found ${blockingCount} critical/high severity CVEs${colors.reset}`);
		console.error("");
		console.error(`${colors.cyan}To fix:${colors.reset}`);
		console.error("   1. Update affected packages to fixed versions");
		console.error("   2. Or add to ignore list if false positive");
		console.error("");
		process.exit(2);
	}

	console.error(`${colors.yellow}âš ï¸ Found ${mediumCount} medium severity CVEs (not blocking)${colors.reset}`);
	process.exit(0);
}

main().catch(err => {
	console.error(`[ERROR] ${err.message}`);
	process.exit(0);
});
